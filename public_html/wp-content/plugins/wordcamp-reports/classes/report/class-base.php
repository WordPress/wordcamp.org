<?php
/**
 * @package WordCamp\Reports
 */

namespace WordCamp\Reports\Report;
defined( 'WPINC' ) || die();

use WP_Error, WP_Post, WP_REST_Response;

/**
 * Class Base
 *
 * A base report class with methods for filtering and caching data, and handling errors, plus some other helper methods.
 *
 * Things to keep in mind when writing a new report
 *  - Currently all reports extend `Date_Range` range than extending this directly. If your new report isn't based
 *    on pulling data between a date range, then you might want to write a new abstract class that's similar to
 *    `Date_Range`, or just extend this directly, depending on the likelihood of that new abstract class being
 *    reused in the future.
 *  - Most reports are displayed to both public and private audiences, so be careful that private data is never
 *    exposed to the public. See `$private_data_fields`, `$public_data_fields`, and `filter_data_fields()`.
 *  - You'll probably need to update https://central.wordcamp.org/reports/ with a link to the new reports. In the
 *    future, this could be automated.
 *  - `get_data()` typically returns the raw data (like for a CSV export), while `compile_report_data()` creates
 *    user-facing summaries and tables based on the raw data.
 *  - In wp-admin, the UI is generated by combining `views/report` with `views/html`; the former is the header and
 *    wrapper markup, while the latter is the markup for the actual data.
 *  - On the front end, the public reports are rendered by combining `views/public` with `views/html`.
 *  - REST API endpoints are created by some of the classes, but not actually used by this plugin yet.
 *
 * @package WordCamp\Reports\Report
 */
abstract class Base {
	/**
	 * Report name.
	 *
	 * @var string
	 */
	public static $name = '';

	/**
	 * Report slug.
	 *
	 * @var string
	 */
	public static $slug = '';

	/**
	 * Report description.
	 *
	 * @var string
	 */
	public static $description = '';

	/**
	 * Report methodology.
	 *
	 * @var string
	 */
	public static $methodology = '';

	/**
	 * Report group.
	 *
	 * @var string
	 */
	public static $group = '';

	/**
	 * Additional report parameters.
	 *
	 * @var array
	 */
	public $options = array();

	/**
	 * A container object to hold error messages.
	 *
	 * @var \WP_Error
	 */
	public $error = null;

	/**
	 * Data fields that can be visible in a public context.
	 *
	 * @var array An associative array of key/default value pairs.
	 */
	protected $public_data_fields = array();

	/**
	 * Data fields that should only be visible in a private context.
	 *
	 * @var array An associative array of key/default value pairs.
	 */
	protected $private_data_fields = array();

	/**
	 * Base constructor.
	 *
	 * @param array $options    {
	 *     Optional. Additional report parameters.
	 *
	 *     @type bool $cache_data  True to look for cached data and cache the generated data set. Default true.
	 *     @type bool $flush_cache True to delete any cached data generated with the current report parameters. Default false.
	 *     @type bool $public      True if the report data is for public consumption. Reports can use this value to determine
	 *                             whether to redact or remove some fields if necessary. Default true.
	 * }
	 */
	public function __construct( array $options = array() ) {
		wp_raise_memory_limit( 'wordcamp_high' );

		$this->options = wp_parse_args(
			$options,
			array(
				'cache_data'  => true,
				'flush_cache' => false,
				'public'      => true,
			)
		);

		$this->error = new WP_Error();
	}

	/**
	 * Query and parse the data for the report.
	 *
	 * @return array
	 */
	abstract public function get_data();

	/**
	 * Compile the report data into results.
	 *
	 * @param array $data The data to compile.
	 *
	 * @return array
	 */
	abstract public function compile_report_data( array $data );

	/**
	 * Filter the report data prior to caching and compiling.
	 *
	 * @param array $data The data to filter.
	 *
	 * @return array
	 */
	protected function filter_data_fields( array $data ) {
		$safelist = $this->get_data_fields_safelist();

		array_walk(
			$data,
			function ( &$row ) use ( $safelist ) {
				$row = shortcode_atts( $safelist, $row );
			}
		);

		return $data;
	}

	/**
	 * Filter the data rows based on a search query.
	 *
	 * @param array $data
	 *
	 * @return array
	 */
	protected function filter_data_rows( array $data ) {
		if ( empty( $this->options['search_query'] ) ) {
			return $data;
		}

		$terms = explode( ',', $this->options['search_query'] );
		$terms = array_map( 'trim', $terms );

		foreach ( $data as $index => $row ) {
			$match = false;

			foreach ( $terms as $term ) {
				foreach ( $this->options['search_fields'] as $field ) {
					// Private search fields will be missing in the context of a public report.
					if ( ! isset( $row[ $field ] ) ) {
						continue;
					}

					if ( false !== stripos( $row[ $field ], $term ) ) {
						$match = true;
						break 2;
					}
				}
			}

			if ( ! $match ) {
				unset( $data[ $index ] );
			}
		}

		// Re-index the array to remove gaps.
		return array_values( $data );
	}

	/**
	 * Determine the data fields safelist based on the context of the report.
	 *
	 * @return array The list of fields that are safe to include.
	 */
	public function get_data_fields_safelist() {
		$safelist = $this->public_data_fields;

		if ( false === $this->options['public'] ) {
			$safelist = array_merge( $safelist, $this->private_data_fields );
		}

		return $safelist;
	}

	/**
	 * Generate a cache key.
	 *
	 * @return string
	 */
	protected function get_cache_key() {
		$context   = ( false === $this->options['public'] ) ? '_private' : '_public';
		$cache_key = 'report_' . static::$slug . $context;

		return $cache_key;
	}

	/**
	 * Generate a cache expiration interval.
	 *
	 * @return int A time interval in seconds.
	 */
	protected function get_cache_expiration() {
		return WEEK_IN_SECONDS;
	}

	/**
	 * If this instance has caching enabled, retrieve cached data.
	 *
	 * @return mixed|null Null if caching is disabled. Otherwise a cached value, or false if none is available.
	 */
	protected function maybe_get_cached_data() {
		if ( true === $this->options['flush_cache'] ) {
			$this->flush_cache();
			return false;
		} elseif ( false !== $this->options['cache_data'] ) {
			return get_transient( $this->get_cache_key() );
		}

		return null;
	}

	/**
	 * If this instance has caching enabled, cache the supplied data.
	 *
	 * @param mixed $data The data to cache.
	 *
	 * @return bool True if the data was successfully cached. Otherwise false.
	 */
	protected function maybe_cache_data( $data ) {
		if ( false !== $this->options['cache_data'] ) {
			$cache_key  = $this->get_cache_key();
			$expiration = $this->get_cache_expiration();

			return set_transient( $cache_key, $data, $expiration );
		}

		return false;
	}

	/**
	 * Delete the cached data for this report instance, if it exists.
	 *
	 * @return bool
	 */
	protected function flush_cache() {
		return delete_transient( $this->get_cache_key() );
	}

	/**
	 * Merge two error objects into one, new error object.
	 *
	 * @param WP_Error $error1 An error object.
	 * @param WP_Error $error2 An error object.
	 *
	 * @return WP_Error The combined errors of the two parameters.
	 */
	protected function merge_errors( WP_Error $error1, WP_Error $error2 ) {
		$codes = $error2->get_error_codes();

		foreach ( $codes as $code ) {
			$messages = $error2->get_error_messages( $code );

			foreach ( $messages as $message ) {
				$error1->add( $code, $message );
			}
		}

		return $error1;
	}

	/**
	 * Render an HTML notice containing error messages.
	 *
	 * @return void
	 */
	protected function render_error_html() {
		?>
		<div class="notice notice-error">
			<?php foreach ( $this->error->get_error_messages() as $message ) : ?>
				<?php echo wpautop( wp_kses_post( $message ) ); ?>
			<?php endforeach; ?>
		</div>
		<?php
	}

	/**
	 * Prepare report data for a REST response.
	 *
	 * This takes an arbitrary data value and wraps it in a WP REST Response object along with additional
	 * information about the report.
	 *
	 * @param mixed $data                       The data that will go in the `data` parameter of the response.
	 * @param array $additional_response_params Additional top-level parameters to add to the response.
	 *
	 * @return WP_REST_Response
	 */
	protected static function prepare_rest_response( $data, array $additional_response_params = array() ) {
		$response_data = array_merge(
			array(
				'report_name'        => static::$name,
				'report_description' => static::$description,
			),
			$additional_response_params
		);

		$response_data['data'] = $data;

		return new WP_REST_Response( $response_data );
	}
}
